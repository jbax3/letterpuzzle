<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dynamic Letter Puzzle Generator</title>
  <style>
    body {
      background: #f0f0f0;
      font-family: sans-serif;
      text-align: center;
      margin: 20px;
    }
    #controls {
      margin-bottom: 10px;
    }
    canvas {
      background: white;
      border: 1px solid #ccc;
      margin: auto;
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <h1>Letter Puzzle Generator (Full Alphabet, Pan & Zoom, Infinite Grid)</h1>
  <div id="controls">
    <label for="wordInput">Enter a word (A–Z): </label>
    <input type="text" id="wordInput" value="HELLO" maxlength="20">
    <button id="generateButton">Generate Puzzle</button>
    <p>Drag to pan; use the mouse wheel to zoom.</p>
  </div>
  <canvas id="puzzleCanvas" width="900" height="350"></canvas>

  <script>
    // -------------------------------
    // Global Variables for Pan & Zoom
    // -------------------------------
    let panX = 0, panY = 0;
    let scale = 1;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    // -------------------------------
    // Global Variables for Puzzle Data
    // -------------------------------
    let currentPuzzleSegments = []; // Holds generated segments
    let currentPuzzleBBoxes = [];   // Bounding boxes for collision checking

    // -------------------------------
    // Letter Definitions (Full Alphabet)
    // -------------------------------
    // Each letter is defined on a local 5×7 grid (x: 0–4, y: 0–6)
    // using only horizontal and vertical segments.
    // These definitions are simplified approximations with some tweaks (e.g. M, N, W).
    const letterData = {
      "A": [
        { start: [1,0], end: [3,0] },   // top horizontal
        { start: [0,1], end: [0,5] },   // left vertical
        { start: [4,1], end: [4,5] },   // right vertical
        { start: [1,3], end: [3,3] }    // middle horizontal
      ],
      "B": [
        { start: [0,0], end: [0,6] },
        { start: [0,0], end: [3,0] },
        { start: [3,0], end: [3,3] },
        { start: [0,3], end: [3,3] },
        { start: [3,3], end: [3,6] },
        { start: [0,6], end: [3,6] }
      ],
      "C": [
        { start: [3,0], end: [0,0] },
        { start: [0,0], end: [0,6] },
        { start: [0,6], end: [3,6] }
      ],
      "D": [
        { start: [0,0], end: [0,6] },
        { start: [0,0], end: [3,0] },
        { start: [3,0], end: [3,6] },
        { start: [0,6], end: [3,6] }
      ],
      "E": [
        { start: [3,0], end: [0,0] },
        { start: [0,0], end: [0,6] },
        { start: [0,3], end: [2,3] },
        { start: [0,6], end: [3,6] }
      ],
      "F": [
        { start: [0,0], end: [3,0] },
        { start: [0,0], end: [0,6] },
        { start: [0,3], end: [2,3] }
      ],
      "G": [
        { start: [3,0], end: [0,0] },
        { start: [0,0], end: [0,6] },
        { start: [0,6], end: [3,6] },
        { start: [3,6], end: [3,3] },
        { start: [2,3], end: [3,3] }
      ],
      "H": [
        { start: [0,0], end: [0,6] },
        { start: [4,0], end: [4,6] },
        { start: [0,3], end: [4,3] }
      ],
      "I": [
        { start: [2,0], end: [2,6] },
        { start: [0,0], end: [4,0] },
        { start: [0,6], end: [4,6] }
      ],
      "J": [
        { start: [4,0], end: [4,6] },
        { start: [4,6], end: [0,6] }
      ],
      "K": [
        { start: [0,0], end: [0,6] },
        { start: [0,3], end: [3,3] },
        { start: [3,0], end: [3,3] },
        { start: [3,3], end: [3,6] }
      ],
      "L": [
        { start: [0,0], end: [0,6] },
        { start: [0,6], end: [4,6] }
      ],
      // --- Updated "M": Uses stepped approximations for the diagonals.
      "M": [
        { start: [0,6], end: [0,0] },   // left vertical (bottom-to-top)
        { start: [0,0], end: [2,0] },   // top horizontal (left part)
        { start: [2,0], end: [2,3] },   // vertical down from top middle
        { start: [2,3], end: [4,3] },   // horizontal connecting left & right diagonals
        { start: [4,3], end: [4,0] },   // vertical up for right diagonal
        { start: [4,0], end: [4,6] }    // right vertical
      ],
      // --- Updated "N": Uses a stepped diagonal.
      "N": [
        { start: [0,6], end: [0,0] },   // left vertical
        { start: [0,0], end: [2,3] },   // stepped diagonal part 1
        { start: [2,3], end: [4,6] },   // stepped diagonal part 2
        { start: [4,6], end: [4,0] }    // right vertical (top-to-bottom)
      ],
      "O": [
        { start: [0,0], end: [4,0] },
        { start: [4,0], end: [4,6] },
        { start: [4,6], end: [0,6] },
        { start: [0,6], end: [0,0] }
      ],
      "P": [
        { start: [0,0], end: [0,6] },
        { start: [0,0], end: [4,0] },
        { start: [4,0], end: [4,3] },
        { start: [0,3], end: [4,3] }
      ],
      "Q": [
        { start: [0,0], end: [4,0] },
        { start: [4,0], end: [4,6] },
        { start: [4,6], end: [0,6] },
        { start: [0,6], end: [0,0] },
        { start: [3,4], end: [4,6] }    // extra tail stroke
      ],
      "R": [
        { start: [0,0], end: [0,6] },
        { start: [0,0], end: [4,0] },
        { start: [4,0], end: [4,3] },
        { start: [0,3], end: [4,3] },
        { start: [2,3], end: [2,6] }
      ],
      "S": [
        { start: [4,0], end: [0,0] },
        { start: [0,0], end: [0,3] },
        { start: [0,3], end: [4,3] },
        { start: [4,3], end: [4,6] },
        { start: [4,6], end: [0,6] }
      ],
      "T": [
        { start: [0,0], end: [4,0] },
        { start: [2,0], end: [2,6] }
      ],
      "U": [
        { start: [0,0], end: [0,5] },
        { start: [4,0], end: [4,5] },
        { start: [0,5], end: [4,5] }
      ],
      // For "V", reuse U's design.
      "V": [
        { start: [0,0], end: [0,5] },
        { start: [4,0], end: [4,5] },
        { start: [0,5], end: [4,5] }
      ],
      // --- Updated "W": Uses a stepped diagonal with a lower middle point.
      "W": [
        { start: [0,0], end: [0,6] },
        { start: [0,6], end: [2,4] },
        { start: [2,4], end: [4,6] },
        { start: [4,6], end: [4,0] }
      ],
      // "X" is approximated as a plus sign.
      "X": [
        { start: [2,0], end: [2,6] },
        { start: [0,3], end: [4,3] }
      ],
      // "Y" approximated as a T.
      "Y": [
        { start: [0,0], end: [4,0] },
        { start: [2,0], end: [2,6] }
      ],
      "Z": [
        { start: [0,0], end: [4,0] },
        { start: [0,3], end: [4,3] },
        { start: [0,6], end: [4,6] }
      ]
    };

    // -------------------------------
    // Global Settings for Drawing
    // -------------------------------
    const canvas = document.getElementById("puzzleCanvas");
    const ctx = canvas.getContext("2d");
    const gridUnit = 20; // 1 grid unit = 20 pixels

    // Colors for successive letters (cycling if needed)
    const letterColors = ["red", "blue", "green", "darkorange", "purple", "teal", "maroon", "navy"];

    // -------------------------------
    // Utility Drawing Functions
    // -------------------------------
    // drawGrid now draws grid lines over the entire visible area, regardless of pan/zoom.
    function drawGrid(canvasWidth, canvasHeight) {
      // Compute visible world coordinates based on current pan and scale.
      const minX = (-panX) / scale;
      const minY = (-panY) / scale;
      const maxX = (canvasWidth - panX) / scale;
      const maxY = (canvasHeight - panY) / scale;

      ctx.strokeStyle = "#ddd";
      ctx.lineWidth = 1;

      // Draw vertical grid lines.
      for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {
        ctx.beginPath();
        ctx.moveTo(x * gridUnit, minY * gridUnit);
        ctx.lineTo(x * gridUnit, maxY * gridUnit);
        ctx.stroke();
      }
      // Draw horizontal grid lines.
      for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {
        ctx.beginPath();
        ctx.moveTo(minX * gridUnit, y * gridUnit);
        ctx.lineTo(maxX * gridUnit, y * gridUnit);
        ctx.stroke();
      }
    }

    function drawCircle(x, y, color) {
      ctx.beginPath();
      ctx.arc(x * gridUnit, y * gridUnit, gridUnit * 0.15, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawLine(x1, y1, x2, y2, color, lineWidth = 4) {
      ctx.beginPath();
      ctx.moveTo(x1 * gridUnit, y1 * gridUnit);
      ctx.lineTo(x2 * gridUnit, y2 * gridUnit);
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }

    // Draw an arrow with increased length.
    function drawArrow(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1 * gridUnit, y1 * gridUnit);
      ctx.lineTo(x2 * gridUnit, y2 * gridUnit);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.stroke();

      const angle = Math.atan2((y2 - y1) * gridUnit, (x2 - x1) * gridUnit);
      const headLength = 15;
      const angleOffset = Math.PI / 7;
      const arrowX1 = x2 * gridUnit - headLength * Math.cos(angle - angleOffset);
      const arrowY1 = y2 * gridUnit - headLength * Math.sin(angle - angleOffset);
      const arrowX2 = x2 * gridUnit - headLength * Math.cos(angle + angleOffset);
      const arrowY2 = y2 * gridUnit - headLength * Math.sin(angle + angleOffset);
      ctx.beginPath();
      ctx.moveTo(x2 * gridUnit, y2 * gridUnit);
      ctx.lineTo(arrowX1, arrowY1);
      ctx.lineTo(arrowX2, arrowY2);
      ctx.lineTo(x2 * gridUnit, y2 * gridUnit);
      ctx.fillStyle = "black";
      ctx.fill();
    }

    function drawText(text, x, y) {
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "black";
      ctx.fillText(text, x * gridUnit, y * gridUnit);
    }

    // -------------------------------
    // Overlap Helper Functions
    // -------------------------------
    function getBBox(x1, y1, x2, y2) {
      const margin = 0.1;
      return {
        minX: Math.min(x1, x2) - margin,
        minY: Math.min(y1, y2) - margin,
        maxX: Math.max(x1, x2) + margin,
        maxY: Math.max(y1, y2) + margin
      };
    }
    function boxesOverlap(b1, b2) {
      return !(b1.maxX < b2.minX || b1.minX > b2.maxX || b1.maxY < b2.minY || b1.minY > b2.maxY);
    }
    function overlapsAny(bbox, bboxArray) {
      for (let i = 0; i < bboxArray.length; i++) {
        if (boxesOverlap(bbox, bboxArray[i])) return true;
      }
      return false;
    }

    // -------------------------------
    // Puzzle Generation
    // -------------------------------
    function getAllowedMoves() {
      const moves = [];
      for (let m = 1; m <= 3; m++) {
        moves.push([0, m]);    // up
        moves.push([0, -m]);   // down
        moves.push([m, 0]);    // left
        moves.push([-m, 0]);   // right
      }
      return moves;
    }
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // generatePuzzle computes each segment’s final position (with letter offsets)
    // and then chooses a candidate move (pure horizontal/vertical, magnitude 1–3)
    // so that the scattered initial position (final minus move) does not overlap
    // previously placed segments.
    function generatePuzzle(word) {
      currentPuzzleSegments = [];
      currentPuzzleBBoxes = [];
      
      const letterSpacing = 1;  // extra grid unit between letters
      const letterWidth = 6;    // design width
      const verticalOffset = 3; // shift letters downward
      let currentXOffset = 2;   // left margin

      for (let i = 0; i < word.length; i++) {
        const ch = word[i].toUpperCase();
        if (!letterData[ch]) {
          console.warn("Unsupported letter: " + ch);
          continue;
        }
        const segments = letterData[ch];
        const color = letterColors[i % letterColors.length];

        segments.forEach(seg => {
          const finalStart = [ seg.start[0] + currentXOffset, seg.start[1] + verticalOffset ];
          const finalEnd   = [ seg.end[0]   + currentXOffset, seg.end[1]   + verticalOffset ];
          const allowedMoves = getAllowedMoves();
          shuffleArray(allowedMoves);
          let chosenMove = null;
          let candidateBBox = null;
          for (let candidate of allowedMoves) {
            const initStart = [ finalStart[0] - candidate[0], finalStart[1] - candidate[1] ];
            const initEnd   = [ finalEnd[0]   - candidate[0], finalEnd[1]   - candidate[1] ];
            const bbox = getBBox(initStart[0], initStart[1], initEnd[0], initEnd[1]);
            if (!overlapsAny(bbox, currentPuzzleBBoxes)) {
              chosenMove = candidate;
              candidateBBox = bbox;
              break;
            }
          }
          if (chosenMove === null) {
            chosenMove = [0, 0];
            const initStart = [ finalStart[0], finalStart[1] ];
            const initEnd   = [ finalEnd[0], finalEnd[1] ];
            candidateBBox = getBBox(initStart[0], initStart[1], initEnd[0], initEnd[1]);
          }
          const initStart = [ finalStart[0] - chosenMove[0], finalStart[1] - chosenMove[1] ];
          const initEnd   = [ finalEnd[0]   - chosenMove[0], finalEnd[1]   - chosenMove[1] ];
          currentPuzzleSegments.push({
            finalStart, finalEnd,
            initStart, initEnd,
            move: chosenMove,
            color
          });
          currentPuzzleBBoxes.push(candidateBBox);
        });
        currentXOffset += letterWidth + letterSpacing;
      }
      drawPuzzle();
    }

    // -------------------------------
    // Drawing the Puzzle with Pan & Zoom
    // -------------------------------
    function drawPuzzle() {
      ctx.save();
      // Set transform for pan and zoom.
      ctx.setTransform(scale, 0, 0, scale, panX, panY);
      // Clear entire canvas in world coordinates.
      ctx.clearRect(-panX/scale, -panY/scale, canvas.width/scale, canvas.height/scale);

      // Draw grid over the full visible area.
      drawGrid(canvas.width, canvas.height);

      // Draw each segment.
      currentPuzzleSegments.forEach(seg => {
        const [x1, y1] = seg.initStart;
        const [x2, y2] = seg.initEnd;
        drawLine(x1, y1, x2, y2, seg.color);
        drawCircle(x1, y1, seg.color);
        drawCircle(x2, y2, seg.color);

        const bbox = getBBox(x1, y1, x2, y2);
        // Draw arrow starting at the top-right of the segment's bounding box.
        const arrowStartX = bbox.maxX;
        const arrowStartY = bbox.minY;
        const arrowLength = 1.5; // in grid units
        let dx = 0, dy = 0;
        if (seg.move[0] > 0) dx = arrowLength;
        else if (seg.move[0] < 0) dx = -arrowLength;
        if (seg.move[1] > 0) dy = arrowLength;
        else if (seg.move[1] < 0) dy = -arrowLength;
        drawArrow(arrowStartX, arrowStartY, arrowStartX + dx, arrowStartY + dy);
        const moveMag = Math.abs(seg.move[0]) + Math.abs(seg.move[1]);
        drawText(moveMag, bbox.maxX + 0.2, bbox.minY - 0.2);
      });
      ctx.restore();
    }

    // -------------------------------
    // UI Interaction for Puzzle Generation
    // -------------------------------
    document.getElementById("generateButton").addEventListener("click", () => {
      const word = document.getElementById("wordInput").value.trim() || "HELLO";
      // Reset pan/zoom.
      panX = 0; panY = 0; scale = 1;
      generatePuzzle(word);
    });

    // -------------------------------
    // Pan/Zoom Event Handlers
    // -------------------------------
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX - panX;
      dragStart.y = e.clientY - panY;
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        panX = e.clientX - dragStart.x;
        panY = e.clientY - dragStart.y;
        drawPuzzle();
      }
    });
    canvas.addEventListener("mouseup", () => { isDragging = false; });
    canvas.addEventListener("mouseleave", () => { isDragging = false; });
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      if (e.deltaY < 0) {  // zoom in
        scale *= zoomFactor;
      } else {             // zoom out
        scale /= zoomFactor;
      }
      drawPuzzle();
    });

    // -------------------------------
    // Generate initial puzzle on load.
    // -------------------------------
    window.onload = () => {
      const word = document.getElementById("wordInput").value.trim() || "HELLO";
      generatePuzzle(word);
    };
  </script>
</body>
</html>
